{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 \u6b22\u8fce\u6765\u5230 NaDGenLib \u7684\u4f7f\u7528\u624b\u518c\uff01\uff08\u5f53\u7136\uff0c\u4e5f\u662f Larry76 \u7684\u535a\u5ba2\u5566\uff09 \u4e3a\u4e86\u4fdd\u8bc1\u60a8\u7684\u4f7f\u7528\u4f53\u9a8c\uff0c\u4e0b\u9762\u5c06\u4f1a\u5bf9\u4e00\u4e9b\u5185\u5bb9\u8fdb\u884c\u6d4b\u8bd5\uff0c\u8bf7\u67e5\u770b\u5176\u662f\u5426\u6b63\u786e qwq\u3002 \u4e0b\u9762\u662f\u6570\u5b66\u516c\u5f0f \u00b6 \u884c\u5185\u516c\u5f0f\uff1a \\(f(x)=\\sum_{n=0}^m a_nx^n\\) \u884c\u95f4\u516c\u5f0f\uff1a $$ h(x) = \\sum_{d\\mid x} f(d)g(\\frac xd) = \\sum_{ab=x}f(a)g(b) $$ \u4e0b\u9762\u662f\u8868\u683c \u00b6 Language Ratings Python 14.83% C 14.73% Java 13.56% C++ 13.29% C# 7.57% \u4e0b\u9762\u662f\u4ee3\u7801\u6bb5 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 // \u6ca1\u5565\u6d3b\u597d\u6574\u4e86\uff0c\u7ed9\u5927\u5bb6\u54ac\u4e2a\u6253\u706b\u673a\u5427 #include <bits/stdc++.h> using namespace std ; const double alpha = 0.2928 ; typedef struct NODE { int value ; int size ; NODE * lchild , * rchild ; NODE ( int x ){ this -> value = x ; this -> size = 1 ; this -> lchild = this -> rchild = nullptr ; } NODE (){ this -> value = INT_MAX ; this -> size = 0 ; this -> lchild = this -> rchild = nullptr ; } } NODE , * PNODE ; PNODE root ; inline PNODE newNode ( int x ){ return new NODE ( x ); } inline void deleteNode ( PNODE & T ){ delete T ; T = nullptr ; } inline bool isLeaf ( PNODE T ){ return T -> lchild == nullptr ; } inline void pushup ( PNODE T ){ if ( ! isLeaf ( T )){ T -> value = T -> rchild -> value ; T -> size = T -> lchild -> size + T -> rchild -> size ; } } inline void rotate ( PNODE T , bool d ){ PNODE temp ; if ( ! d ){ temp = T -> rchild ; T -> rchild = T -> lchild ; T -> lchild = T -> rchild -> lchild ; T -> rchild -> lchild = T -> rchild -> rchild ; T -> rchild -> rchild = temp ; } else { temp = T -> lchild ; T -> lchild = T -> rchild ; T -> rchild = T -> lchild -> rchild ; T -> lchild -> rchild = T -> lchild -> lchild ; T -> lchild -> lchild = temp ; } pushup ( T -> lchild ); pushup ( T -> rchild ); pushup ( T ); } inline void maintain ( PNODE T ){ bool d = 0 ; if ( ! isLeaf ( T )){ if ( T -> lchild -> size < T -> size * alpha ) d = 1 ; else if ( T -> rchild -> size < T -> size * alpha ) d = 0 ; else return ; if ( d ){ if ( T -> rchild -> lchild -> size >= T -> rchild -> size * ( 1-2 * alpha ) / ( 1 - alpha )) rotate ( T -> rchild , ! d ); } else { if ( T -> lchild -> rchild -> size >= T -> lchild -> size * ( 1-2 * alpha ) / ( 1 - alpha )) rotate ( T -> lchild , ! d ); } rotate ( T , d ); } } inline void Insert ( PNODE T , int x ){ if ( isLeaf ( T )){ T -> lchild = newNode ( x ); T -> rchild = newNode ( T -> value ); if ( T -> lchild -> value > T -> rchild -> value ) swap ( T -> lchild , T -> rchild ); pushup ( T ); return ; } if ( T -> lchild -> value >= x ) Insert ( T -> lchild , x ); else Insert ( T -> rchild , x ); pushup ( T ); maintain ( T ); } inline void Delete ( PNODE & T , int x ){ if ( isLeaf ( T )) return ; if ( x <= T -> lchild -> value ){ if ( isLeaf ( T -> lchild )){ if ( x != T -> lchild -> value ) return ; deleteNode ( T -> lchild ); PNODE buf = T -> rchild ; * T = * buf ; deleteNode ( buf ); } else Delete ( T -> lchild , x ); } else { if ( isLeaf ( T -> rchild )){ if ( x != T -> rchild -> value ) return ; deleteNode ( T -> rchild ); PNODE buf = T -> lchild ; * T = * buf ; deleteNode ( buf ); } else Delete ( T -> rchild , x ); } pushup ( T ); maintain ( T ); } inline int GetRnk ( PNODE T , int x ){ if ( isLeaf ( T )) return 1 ; if ( x <= T -> lchild -> value ) return GetRnk ( T -> lchild , x ); return T -> lchild -> size + GetRnk ( T -> rchild , x ); } inline int GetNum ( PNODE T , int rnk ){ if ( isLeaf ( T )) return T -> value ; if ( rnk <= T -> lchild -> size ) return GetNum ( T -> lchild , rnk ); return GetNum ( T -> rchild , rnk - T -> lchild -> size ); } inline int GetPre ( PNODE T , int num ){ return GetNum ( T , GetRnk ( T , num ) -1 ); } inline int GetSuf ( PNODE T , int num ){ return GetNum ( T , GetRnk ( T , num + 1 )); } int main (){ root = new NODE ; int n ; cin >> n ; while ( n -- ){ int opt ; cin >> opt ; switch ( opt ){ case 1 :{ int x ; cin >> x ; Insert ( root , x ); break ; } case 2 :{ int x ; cin >> x ; Delete ( root , x ); break ; } case 3 :{ int x ; cin >> x ; cout << GetRnk ( root , x ) << endl ; break ; } case 4 :{ int x ; cin >> x ; cout << GetNum ( root , x ) << endl ; break ; } case 5 :{ int x ; cin >> x ; cout << GetPre ( root , x ) << endl ; break ; } case 6 :{ int x ; cin >> x ; cout << GetSuf ( root , x ) << endl ; break ; } } } return 0 ; } \u8fd9\u662f\u6536\u8d77\u6765\u7684\u6837\u5b50 C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #define _CRT_SECURE_NO_WARNINGS #include <opencv.hpp> #include <windows.h> #include <conio.h> using namespace std ; using namespace cv ; #define MAX_COL 1024 #define MAX_ROW 2048 //#define MAX_SIZE 6746 char shadowvector [] = \"@$#%&WASGHKBMRDFZXNVCJLQOTPYEUIab987654321~?!^*()<>+-=[]{},. \" ; long long len ; char framemat [ MAX_ROW ][ MAX_COL ]; char gray2char ( int level ) { level = 255 - level ; return shadowvector [( int ) level / 4 ]; } int main () { len = strlen ( shadowvector ) -1 ; HANDLE handle = GetStdHandle ((( DWORD ) -11 )); CONSOLE_FONT_INFOEX cfi ; cfi . cbSize = sizeof ( CONSOLE_FONT_INFOEX ); COORD size ; size . X = 3 ; size . Y = 5 ; cfi . dwFontSize = size ; wcscpy ( cfi . FaceName , L \"Arial\" ); cfi . FontWeight = 100 ; cfi . FontFamily = TMPF_TRUETYPE ; cfi . nFont = 0 ; SetCurrentConsoleFontEx ( handle , TRUE , & cfi ); int T = 6574 + 1 ; _getch (); double c1 = clock (); while ( -- T ) { int t1 = clock (); char strbuf [ 1024 ]; sprintf ( strbuf , \"./frames/%d.png\" , 6574 - T + 1 ); Mat srcImage = imread ( strbuf ); Mat temImage , dstImage1 ; temImage = srcImage ; resize ( temImage , dstImage1 , Size ( 0 , 0 ), ( double ) 1 / 4 + 1 , ( double ) 1 / 8 + 0.5 , INTER_LINEAR ); cvtColor ( dstImage1 , dstImage1 , COLOR_RGB2GRAY ); int cnt = 0 ; for ( int i = 0 , j ; i < dstImage1 . rows ; i ++ ) { for ( j = 0 ; j < dstImage1 . cols ; j ++ ) framemat [ i ][ j ] = gray2char ( dstImage1 . ptr < uchar > ( i )[ j ]); framemat [ i ][ j ] = '\\0' ; } for ( int i = 0 ; i < dstImage1 . rows ; i ++ ) { COORD pos ; pos . X = 0 ; pos . Y = i ; DWORD real ; WriteConsoleOutputCharacter ( handle , framemat [ i ], strlen ( framemat [ i ]) * sizeof ( char ), pos , & real ); } int t2 = clock (); int sl = 33 - t2 + t1 ; Sleep ( sl < 0 ? 0 : sl ); } double c2 = clock (); printf ( \"%.3lf\" , ( c2 - c1 ) / CLOCKS_PER_SEC ); system ( \"pause\" ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import cv2 ascii_char = list ( \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1 {} []?-_+~<>i!lI;:, \\\" ^`'. \" ) def get_char ( gray_number ): length = len ( ascii_char ) unit = ( 256.0 + 1 ) / length return ascii_char [ int ( gray_number / unit )] def convert ( source , dest ): image1 = cv2 . imread ( source ) image = cv2 . resize ( image1 ,( 232 , 87 )) gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) txt = \"\" for i in range ( image . shape [ 0 ]): for j in range ( image . shape [ 1 ]): txt += get_char ( gray [ i , j ]) txt += ' \\n ' f = open ( dest , 'w' ) f . write ( txt ) if __name__ == '__main__' : for i in range ( 1 , 6574 ): convert ( \" %d .png\" % i , '. \\\\ txt \\\\ %d .txt' % i ); print ( \"Finished Converting %d /6574\" % i , end = ' \\r ' ); \u987a\u4fbf\u6d4b\u8bd5\u4e86\u8f83\u5927\u6587\u4ef6\u4f20\u8f93\uff0c\u8fd8\u6709\u5220\u9664\u7ebf \u4e0b\u9762\u662f\u56fe\u7247 \u00b6 \u6811\u94fe\u5256\u5206\u634f\uff1a AC \u81ea\u52a8\u673a\u634f\uff1a \u987a\u5e26\u4e00\u63d0\uff0c\u4e0a\u8ff0\u56fe\u7247\u5747\u6765\u81ea\u4e8e OI-Wiki","title":"\u5f00\u59cb"},{"location":"#home","text":"\u6b22\u8fce\u6765\u5230 NaDGenLib \u7684\u4f7f\u7528\u624b\u518c\uff01\uff08\u5f53\u7136\uff0c\u4e5f\u662f Larry76 \u7684\u535a\u5ba2\u5566\uff09 \u4e3a\u4e86\u4fdd\u8bc1\u60a8\u7684\u4f7f\u7528\u4f53\u9a8c\uff0c\u4e0b\u9762\u5c06\u4f1a\u5bf9\u4e00\u4e9b\u5185\u5bb9\u8fdb\u884c\u6d4b\u8bd5\uff0c\u8bf7\u67e5\u770b\u5176\u662f\u5426\u6b63\u786e qwq\u3002","title":"Home"},{"location":"#_1","text":"\u884c\u5185\u516c\u5f0f\uff1a \\(f(x)=\\sum_{n=0}^m a_nx^n\\) \u884c\u95f4\u516c\u5f0f\uff1a $$ h(x) = \\sum_{d\\mid x} f(d)g(\\frac xd) = \\sum_{ab=x}f(a)g(b) $$","title":"\u4e0b\u9762\u662f\u6570\u5b66\u516c\u5f0f"},{"location":"#_2","text":"Language Ratings Python 14.83% C 14.73% Java 13.56% C++ 13.29% C# 7.57%","title":"\u4e0b\u9762\u662f\u8868\u683c"},{"location":"#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 // \u6ca1\u5565\u6d3b\u597d\u6574\u4e86\uff0c\u7ed9\u5927\u5bb6\u54ac\u4e2a\u6253\u706b\u673a\u5427 #include <bits/stdc++.h> using namespace std ; const double alpha = 0.2928 ; typedef struct NODE { int value ; int size ; NODE * lchild , * rchild ; NODE ( int x ){ this -> value = x ; this -> size = 1 ; this -> lchild = this -> rchild = nullptr ; } NODE (){ this -> value = INT_MAX ; this -> size = 0 ; this -> lchild = this -> rchild = nullptr ; } } NODE , * PNODE ; PNODE root ; inline PNODE newNode ( int x ){ return new NODE ( x ); } inline void deleteNode ( PNODE & T ){ delete T ; T = nullptr ; } inline bool isLeaf ( PNODE T ){ return T -> lchild == nullptr ; } inline void pushup ( PNODE T ){ if ( ! isLeaf ( T )){ T -> value = T -> rchild -> value ; T -> size = T -> lchild -> size + T -> rchild -> size ; } } inline void rotate ( PNODE T , bool d ){ PNODE temp ; if ( ! d ){ temp = T -> rchild ; T -> rchild = T -> lchild ; T -> lchild = T -> rchild -> lchild ; T -> rchild -> lchild = T -> rchild -> rchild ; T -> rchild -> rchild = temp ; } else { temp = T -> lchild ; T -> lchild = T -> rchild ; T -> rchild = T -> lchild -> rchild ; T -> lchild -> rchild = T -> lchild -> lchild ; T -> lchild -> lchild = temp ; } pushup ( T -> lchild ); pushup ( T -> rchild ); pushup ( T ); } inline void maintain ( PNODE T ){ bool d = 0 ; if ( ! isLeaf ( T )){ if ( T -> lchild -> size < T -> size * alpha ) d = 1 ; else if ( T -> rchild -> size < T -> size * alpha ) d = 0 ; else return ; if ( d ){ if ( T -> rchild -> lchild -> size >= T -> rchild -> size * ( 1-2 * alpha ) / ( 1 - alpha )) rotate ( T -> rchild , ! d ); } else { if ( T -> lchild -> rchild -> size >= T -> lchild -> size * ( 1-2 * alpha ) / ( 1 - alpha )) rotate ( T -> lchild , ! d ); } rotate ( T , d ); } } inline void Insert ( PNODE T , int x ){ if ( isLeaf ( T )){ T -> lchild = newNode ( x ); T -> rchild = newNode ( T -> value ); if ( T -> lchild -> value > T -> rchild -> value ) swap ( T -> lchild , T -> rchild ); pushup ( T ); return ; } if ( T -> lchild -> value >= x ) Insert ( T -> lchild , x ); else Insert ( T -> rchild , x ); pushup ( T ); maintain ( T ); } inline void Delete ( PNODE & T , int x ){ if ( isLeaf ( T )) return ; if ( x <= T -> lchild -> value ){ if ( isLeaf ( T -> lchild )){ if ( x != T -> lchild -> value ) return ; deleteNode ( T -> lchild ); PNODE buf = T -> rchild ; * T = * buf ; deleteNode ( buf ); } else Delete ( T -> lchild , x ); } else { if ( isLeaf ( T -> rchild )){ if ( x != T -> rchild -> value ) return ; deleteNode ( T -> rchild ); PNODE buf = T -> lchild ; * T = * buf ; deleteNode ( buf ); } else Delete ( T -> rchild , x ); } pushup ( T ); maintain ( T ); } inline int GetRnk ( PNODE T , int x ){ if ( isLeaf ( T )) return 1 ; if ( x <= T -> lchild -> value ) return GetRnk ( T -> lchild , x ); return T -> lchild -> size + GetRnk ( T -> rchild , x ); } inline int GetNum ( PNODE T , int rnk ){ if ( isLeaf ( T )) return T -> value ; if ( rnk <= T -> lchild -> size ) return GetNum ( T -> lchild , rnk ); return GetNum ( T -> rchild , rnk - T -> lchild -> size ); } inline int GetPre ( PNODE T , int num ){ return GetNum ( T , GetRnk ( T , num ) -1 ); } inline int GetSuf ( PNODE T , int num ){ return GetNum ( T , GetRnk ( T , num + 1 )); } int main (){ root = new NODE ; int n ; cin >> n ; while ( n -- ){ int opt ; cin >> opt ; switch ( opt ){ case 1 :{ int x ; cin >> x ; Insert ( root , x ); break ; } case 2 :{ int x ; cin >> x ; Delete ( root , x ); break ; } case 3 :{ int x ; cin >> x ; cout << GetRnk ( root , x ) << endl ; break ; } case 4 :{ int x ; cin >> x ; cout << GetNum ( root , x ) << endl ; break ; } case 5 :{ int x ; cin >> x ; cout << GetPre ( root , x ) << endl ; break ; } case 6 :{ int x ; cin >> x ; cout << GetSuf ( root , x ) << endl ; break ; } } } return 0 ; } \u8fd9\u662f\u6536\u8d77\u6765\u7684\u6837\u5b50 C++ Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #define _CRT_SECURE_NO_WARNINGS #include <opencv.hpp> #include <windows.h> #include <conio.h> using namespace std ; using namespace cv ; #define MAX_COL 1024 #define MAX_ROW 2048 //#define MAX_SIZE 6746 char shadowvector [] = \"@$#%&WASGHKBMRDFZXNVCJLQOTPYEUIab987654321~?!^*()<>+-=[]{},. \" ; long long len ; char framemat [ MAX_ROW ][ MAX_COL ]; char gray2char ( int level ) { level = 255 - level ; return shadowvector [( int ) level / 4 ]; } int main () { len = strlen ( shadowvector ) -1 ; HANDLE handle = GetStdHandle ((( DWORD ) -11 )); CONSOLE_FONT_INFOEX cfi ; cfi . cbSize = sizeof ( CONSOLE_FONT_INFOEX ); COORD size ; size . X = 3 ; size . Y = 5 ; cfi . dwFontSize = size ; wcscpy ( cfi . FaceName , L \"Arial\" ); cfi . FontWeight = 100 ; cfi . FontFamily = TMPF_TRUETYPE ; cfi . nFont = 0 ; SetCurrentConsoleFontEx ( handle , TRUE , & cfi ); int T = 6574 + 1 ; _getch (); double c1 = clock (); while ( -- T ) { int t1 = clock (); char strbuf [ 1024 ]; sprintf ( strbuf , \"./frames/%d.png\" , 6574 - T + 1 ); Mat srcImage = imread ( strbuf ); Mat temImage , dstImage1 ; temImage = srcImage ; resize ( temImage , dstImage1 , Size ( 0 , 0 ), ( double ) 1 / 4 + 1 , ( double ) 1 / 8 + 0.5 , INTER_LINEAR ); cvtColor ( dstImage1 , dstImage1 , COLOR_RGB2GRAY ); int cnt = 0 ; for ( int i = 0 , j ; i < dstImage1 . rows ; i ++ ) { for ( j = 0 ; j < dstImage1 . cols ; j ++ ) framemat [ i ][ j ] = gray2char ( dstImage1 . ptr < uchar > ( i )[ j ]); framemat [ i ][ j ] = '\\0' ; } for ( int i = 0 ; i < dstImage1 . rows ; i ++ ) { COORD pos ; pos . X = 0 ; pos . Y = i ; DWORD real ; WriteConsoleOutputCharacter ( handle , framemat [ i ], strlen ( framemat [ i ]) * sizeof ( char ), pos , & real ); } int t2 = clock (); int sl = 33 - t2 + t1 ; Sleep ( sl < 0 ? 0 : sl ); } double c2 = clock (); printf ( \"%.3lf\" , ( c2 - c1 ) / CLOCKS_PER_SEC ); system ( \"pause\" ); return 0 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import cv2 ascii_char = list ( \"$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1 {} []?-_+~<>i!lI;:, \\\" ^`'. \" ) def get_char ( gray_number ): length = len ( ascii_char ) unit = ( 256.0 + 1 ) / length return ascii_char [ int ( gray_number / unit )] def convert ( source , dest ): image1 = cv2 . imread ( source ) image = cv2 . resize ( image1 ,( 232 , 87 )) gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) txt = \"\" for i in range ( image . shape [ 0 ]): for j in range ( image . shape [ 1 ]): txt += get_char ( gray [ i , j ]) txt += ' \\n ' f = open ( dest , 'w' ) f . write ( txt ) if __name__ == '__main__' : for i in range ( 1 , 6574 ): convert ( \" %d .png\" % i , '. \\\\ txt \\\\ %d .txt' % i ); print ( \"Finished Converting %d /6574\" % i , end = ' \\r ' ); \u987a\u4fbf\u6d4b\u8bd5\u4e86\u8f83\u5927\u6587\u4ef6\u4f20\u8f93\uff0c\u8fd8\u6709\u5220\u9664\u7ebf","title":"\u4e0b\u9762\u662f\u4ee3\u7801\u6bb5"},{"location":"#_4","text":"\u6811\u94fe\u5256\u5206\u634f\uff1a AC \u81ea\u52a8\u673a\u634f\uff1a \u987a\u5e26\u4e00\u63d0\uff0c\u4e0a\u8ff0\u56fe\u7247\u5747\u6765\u81ea\u4e8e OI-Wiki","title":"\u4e0b\u9762\u662f\u56fe\u7247"},{"location":"NaDGenLib-docs/","text":"NaDGenLib \u7b80\u4ecb \u00b6 \u8fd9\u662f\u4e00\u4e2a\u7528\u4e8e\u751f\u6210\u6734\u7d20\u6570\u636e\u7684\u5e73\u51e1\u7684\u5e93 \u00b6 \u56e0\u4e3a\u81ea\u5df1\u5e73\u65f6\u60f3\u9893\u5e9f\u4e0d\u60f3\u88ab\u6293\uff0c\u4e8e\u662f\u53ea\u597d\u7ec3\u7ec3\u6784\u9020\uff0c\u987a\u5e26\u5199\u4e00\u4e2a\u5e93\u7ed9\u5927\u5bb6\u73a9\u3002 \u8fd9\u4e2a\u5e93\u53ef\u4ee5\u5e72\u4ec0\u4e48\uff1f \u00b6 \u5982\u679c\u4f60\u60f3\u5feb\u901f\u751f\u6210\u4e00\u9053\u9898\u7684\u57fa\u51c6\u6570\u636e\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5e93\u53ef\u80fd\u662f\u4f60\u7684\u4e0d\u4e8c\u9009\u62e9\u3002 \u8fd9\u4e2a\u5e93\u6ca1\u6709\u4ec0\u4e48\u522b\u7684\u4f18\u70b9\uff0c\u4e3b\u8981\u662f\u5176\u6781\u9ad8\u7684\u81ea\u7531\u5ea6\u548c\u7b80\u77ed\u7684\u4ee3\u7801\u3002 \u7b80\u77ed\u7684\u4ee3\u7801\uff1f\u5bf9\uff0c\u4f60\u6ca1\u542c\u9519\uff0c\u5982\u679c\u4f60\u8981\u662f\u60f3\u751f\u6210\u4e00\u5f20\u6297 SPFA \u7684\u56fe\uff0c\u4f60\u53ef\u80fd\u53ea\u9700\u8981\u5199\u5be5\u5be5\u51e0\u884c\u4ee3\u7801\uff0c\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <bits/stdc++.h> #include \"genlib.h\" using namespace std ; using namespace Generator ; const int vmin = 114514 ; const int vmax = 1919810 ; void CustomFunction (){ AntiSPFA atspfa ( 10 , 1e5 / 10 ); atspfa . AutoMode ( vmin , vmax ); } int main (){ AutoGenerate ( \". \\\\ data \\\\ test%d.in\" , 1 , 10 , CustomFunction ); return 0 ; } \u8fd8\u6709\u66f4\u591a\u7684\u529f\u80fd\uff0c\u540e\u9762\u4f1a\u6162\u6162\u9053\u6765\u3002 \u4f60\u8fd9\u5e93\u8981\u662f\u4e0d\u4fdd\u719f\u548b\u529e\uff1f \u00b6 \u4e0d\u4fdd\u719f\uff1f\u6211\u76f4\u63a5\u8ba9\u4f60\u6210\u4e3a\u7ef4\u62a4\u4e4b\u4e00\uff0c\u8ddf\u6211\u4e00\u8d77\u4e71\u641e\uff01 \u662f\u7684\uff0c\u4f60\u6ca1\u542c\u9519\uff0c\u5982\u679c\u4f60\u53d1\u73b0\u4e86\u5f53\u524d\u5e93\u6709\u4ec0\u4e48 \\(\\text{BUG}\\) \uff0c\u53ef\u4ee5\u76f4\u63a5\u53c2\u4e0e\u4ed3\u5e93\u7684 \\(\\text{Pull Request}\\) \uff0c\u4e0d\u8fc7 \\(\\text{Pull Request}\\) \u7684\u8981\u6c42\u8fd8\u662f\u4e0d\u5c11\u7684\uff0c\u5982\u679c\u4f60\u65e0\u6cd5\u6ee1\u8db3\u4ee5\u4e0b\u8981\u6c42\u4e2d\u7684\u51e0\u70b9\u7684\u8bdd\uff0c\u8bf7\u4e0d\u8981\u63d0\u4ea4 \\(\\text{Pull Request}\\) \uff08\u5c31\u7b97\u63d0\u4ea4\u4e86\u6211\u4e5f\u7ed9\u4f60\u9a73\u56de\u6389\uff09\uff1a \u8bf7\u5c3d\u91cf\u4f7f\u4ee3\u7801\u98ce\u683c\u57fa\u4e8e Google \u7f16\u7801\u89c4\u8303\uff0c\u5e76\u5728\u4fdd\u8bc1\u6b63\u786e\u7684\u524d\u63d0\u4e0b\u5c3d\u53ef\u80fd\u4f18\u79c0\u3002 \u8bf7\u5199\u597d Doxygen \u6ce8\u91ca\u3002 \u5982\u679c\u611f\u89c9\u65e0\u6cd5\u5199\u597d\uff0c\u8bf7\u63d0\u4ea4 \\(\\text{Issue}\\) \u800c\u4e0d\u662f \\(\\text{Pull Request}\\) \u3002 \u8bf7\u5728 \\(\\text{Pull Request}\\) \u4e4b\u524d\u63d0\u4ea4 \\(\\text{Issue}\\) \uff0c\u7136\u540e\u518d \\(\\text{Pull Request}\\) \u4e2d\u5f15\u7528\u4f60\u6240\u63d0\u4ea4\u7684 \\(\\text{Issue}\\) \u3002 \u8bf7\u5728\u4fdd\u8bc1\u6b63\u786e\u7684\u524d\u63d0\u4e0b\u5c3d\u53ef\u80fd\u7684\u7ed9\u4e88\u4f7f\u7528\u8005\u9ad8\u5ea6\u7684\u81ea\u7531\u6027\uff0c\u5373\u53ef\u4f9b\u5176\u9009\u62e9\u7684\u9879\u8981\u66f4\u591a\u3002 \u5982\u679c\u4e0d\u80fd\u4fdd\u8bc1\u4e0a\u8ff0\u5185\u5bb9\uff0c\u8bf7\u9075\u5faa\u7b2c\u4e09\u6761\uff0c\u5728\u63d0\u4ea4 \\(\\text{Issue}\\) \u7684\u65f6\u5019\uff0c\u8bf7\u52a1\u5fc5\u9075\u5faa\u4ee5\u4e0b\u539f\u5219\uff08\u5426\u5219\u76f4\u63a5 \\(\\text{close}\\) \uff09\uff1a \u8bf7\u5c06\u51fa\u73b0\u95ee\u9898\u7684\u6e90\u4ee3\u7801\u5b8c\u6574\u7684\u5c55\u793a\u51fa\u6765\u3002 \u8bf7\u4fdd\u8bc1\u81ea\u5df1\u6240\u4f7f\u7528\u7684\u5e93\u662f\u6700\u65b0\u7248\u672c\uff0c\u5982\u679c\u56e0\u4e3a\u65f6\u95f4\u5dee\u5bfc\u81f4\u800c\u6ca1\u6709\u6ce8\u610f\u5230\u8fd9\u4e2a\u95ee\u9898\u7684\u2026\u2026\uff08\u597d\u50cf\u4e5f\u53ef\u4ee5 \\(\\text{close}\\) \u4e86\uff09\u3002 \u8bf7\u5c06\u95ee\u9898\u63cf\u8ff0\u6e05\u695a\uff0c\u5e76\u7ed9\u4e88\u6784\u9020\u65f6\u53d1\u751f\u9519\u8bef\u7684\u6570\u636e\u3002\u5982\u679c\u6570\u636e\u592a\u5927\u653e\u4e0d\u5f00\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u5c06\u5176\u6254\u5230\u7f51\u76d8\u4e0a\u3002 \u8bf7\u4fdd\u8bc1\u81ea\u5df1\u7684\u4ee3\u7801\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\u3002 \u5982\u679c\u662f\u8bf7\u6c42\u6dfb\u52a0\u529f\u80fd\u7684 \\(\\text{Issue}\\) \uff0c\u8bf7\u5c06\u8981\u6c42\u63cf\u8ff0\u6e05\u695a\uff01 \u5982\u679c\u4f60\u60f3\u8ba9\u6211\u6dfb\u52a0\u4ec0\u4e48\u5947\u602a\u7684\u529f\u80fd\u7684\u8bdd\uff0c\u8bf7\u63d0\u4ea4 \\(\\text{Issue}\\) \u3002 \u5982\u679c\u4f60\u60f3\u62ff\u6211\u7684\u5e93\u8fdb\u884c\u5546\u7528\uff08\u4f1a\u6709\u8fd9\u6837\u7684\u4eba\u5417\uff1f\uff09\u2026\u2026\u8bf7\u9075\u5faa \\(\\text{MPLv2}\\) \u534f\u8bae\u3002","title":"\u7b80\u4ecb"},{"location":"NaDGenLib-docs/#nadgenlib","text":"","title":"NaDGenLib \u7b80\u4ecb"},{"location":"NaDGenLib-docs/#_1","text":"\u56e0\u4e3a\u81ea\u5df1\u5e73\u65f6\u60f3\u9893\u5e9f\u4e0d\u60f3\u88ab\u6293\uff0c\u4e8e\u662f\u53ea\u597d\u7ec3\u7ec3\u6784\u9020\uff0c\u987a\u5e26\u5199\u4e00\u4e2a\u5e93\u7ed9\u5927\u5bb6\u73a9\u3002","title":"\u8fd9\u662f\u4e00\u4e2a\u7528\u4e8e\u751f\u6210\u6734\u7d20\u6570\u636e\u7684\u5e73\u51e1\u7684\u5e93"},{"location":"NaDGenLib-docs/#_2","text":"\u5982\u679c\u4f60\u60f3\u5feb\u901f\u751f\u6210\u4e00\u9053\u9898\u7684\u57fa\u51c6\u6570\u636e\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5e93\u53ef\u80fd\u662f\u4f60\u7684\u4e0d\u4e8c\u9009\u62e9\u3002 \u8fd9\u4e2a\u5e93\u6ca1\u6709\u4ec0\u4e48\u522b\u7684\u4f18\u70b9\uff0c\u4e3b\u8981\u662f\u5176\u6781\u9ad8\u7684\u81ea\u7531\u5ea6\u548c\u7b80\u77ed\u7684\u4ee3\u7801\u3002 \u7b80\u77ed\u7684\u4ee3\u7801\uff1f\u5bf9\uff0c\u4f60\u6ca1\u542c\u9519\uff0c\u5982\u679c\u4f60\u8981\u662f\u60f3\u751f\u6210\u4e00\u5f20\u6297 SPFA \u7684\u56fe\uff0c\u4f60\u53ef\u80fd\u53ea\u9700\u8981\u5199\u5be5\u5be5\u51e0\u884c\u4ee3\u7801\uff0c\u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <bits/stdc++.h> #include \"genlib.h\" using namespace std ; using namespace Generator ; const int vmin = 114514 ; const int vmax = 1919810 ; void CustomFunction (){ AntiSPFA atspfa ( 10 , 1e5 / 10 ); atspfa . AutoMode ( vmin , vmax ); } int main (){ AutoGenerate ( \". \\\\ data \\\\ test%d.in\" , 1 , 10 , CustomFunction ); return 0 ; } \u8fd8\u6709\u66f4\u591a\u7684\u529f\u80fd\uff0c\u540e\u9762\u4f1a\u6162\u6162\u9053\u6765\u3002","title":"\u8fd9\u4e2a\u5e93\u53ef\u4ee5\u5e72\u4ec0\u4e48\uff1f"},{"location":"NaDGenLib-docs/#_3","text":"\u4e0d\u4fdd\u719f\uff1f\u6211\u76f4\u63a5\u8ba9\u4f60\u6210\u4e3a\u7ef4\u62a4\u4e4b\u4e00\uff0c\u8ddf\u6211\u4e00\u8d77\u4e71\u641e\uff01 \u662f\u7684\uff0c\u4f60\u6ca1\u542c\u9519\uff0c\u5982\u679c\u4f60\u53d1\u73b0\u4e86\u5f53\u524d\u5e93\u6709\u4ec0\u4e48 \\(\\text{BUG}\\) \uff0c\u53ef\u4ee5\u76f4\u63a5\u53c2\u4e0e\u4ed3\u5e93\u7684 \\(\\text{Pull Request}\\) \uff0c\u4e0d\u8fc7 \\(\\text{Pull Request}\\) \u7684\u8981\u6c42\u8fd8\u662f\u4e0d\u5c11\u7684\uff0c\u5982\u679c\u4f60\u65e0\u6cd5\u6ee1\u8db3\u4ee5\u4e0b\u8981\u6c42\u4e2d\u7684\u51e0\u70b9\u7684\u8bdd\uff0c\u8bf7\u4e0d\u8981\u63d0\u4ea4 \\(\\text{Pull Request}\\) \uff08\u5c31\u7b97\u63d0\u4ea4\u4e86\u6211\u4e5f\u7ed9\u4f60\u9a73\u56de\u6389\uff09\uff1a \u8bf7\u5c3d\u91cf\u4f7f\u4ee3\u7801\u98ce\u683c\u57fa\u4e8e Google \u7f16\u7801\u89c4\u8303\uff0c\u5e76\u5728\u4fdd\u8bc1\u6b63\u786e\u7684\u524d\u63d0\u4e0b\u5c3d\u53ef\u80fd\u4f18\u79c0\u3002 \u8bf7\u5199\u597d Doxygen \u6ce8\u91ca\u3002 \u5982\u679c\u611f\u89c9\u65e0\u6cd5\u5199\u597d\uff0c\u8bf7\u63d0\u4ea4 \\(\\text{Issue}\\) \u800c\u4e0d\u662f \\(\\text{Pull Request}\\) \u3002 \u8bf7\u5728 \\(\\text{Pull Request}\\) \u4e4b\u524d\u63d0\u4ea4 \\(\\text{Issue}\\) \uff0c\u7136\u540e\u518d \\(\\text{Pull Request}\\) \u4e2d\u5f15\u7528\u4f60\u6240\u63d0\u4ea4\u7684 \\(\\text{Issue}\\) \u3002 \u8bf7\u5728\u4fdd\u8bc1\u6b63\u786e\u7684\u524d\u63d0\u4e0b\u5c3d\u53ef\u80fd\u7684\u7ed9\u4e88\u4f7f\u7528\u8005\u9ad8\u5ea6\u7684\u81ea\u7531\u6027\uff0c\u5373\u53ef\u4f9b\u5176\u9009\u62e9\u7684\u9879\u8981\u66f4\u591a\u3002 \u5982\u679c\u4e0d\u80fd\u4fdd\u8bc1\u4e0a\u8ff0\u5185\u5bb9\uff0c\u8bf7\u9075\u5faa\u7b2c\u4e09\u6761\uff0c\u5728\u63d0\u4ea4 \\(\\text{Issue}\\) \u7684\u65f6\u5019\uff0c\u8bf7\u52a1\u5fc5\u9075\u5faa\u4ee5\u4e0b\u539f\u5219\uff08\u5426\u5219\u76f4\u63a5 \\(\\text{close}\\) \uff09\uff1a \u8bf7\u5c06\u51fa\u73b0\u95ee\u9898\u7684\u6e90\u4ee3\u7801\u5b8c\u6574\u7684\u5c55\u793a\u51fa\u6765\u3002 \u8bf7\u4fdd\u8bc1\u81ea\u5df1\u6240\u4f7f\u7528\u7684\u5e93\u662f\u6700\u65b0\u7248\u672c\uff0c\u5982\u679c\u56e0\u4e3a\u65f6\u95f4\u5dee\u5bfc\u81f4\u800c\u6ca1\u6709\u6ce8\u610f\u5230\u8fd9\u4e2a\u95ee\u9898\u7684\u2026\u2026\uff08\u597d\u50cf\u4e5f\u53ef\u4ee5 \\(\\text{close}\\) \u4e86\uff09\u3002 \u8bf7\u5c06\u95ee\u9898\u63cf\u8ff0\u6e05\u695a\uff0c\u5e76\u7ed9\u4e88\u6784\u9020\u65f6\u53d1\u751f\u9519\u8bef\u7684\u6570\u636e\u3002\u5982\u679c\u6570\u636e\u592a\u5927\u653e\u4e0d\u5f00\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u5c06\u5176\u6254\u5230\u7f51\u76d8\u4e0a\u3002 \u8bf7\u4fdd\u8bc1\u81ea\u5df1\u7684\u4ee3\u7801\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\u3002 \u5982\u679c\u662f\u8bf7\u6c42\u6dfb\u52a0\u529f\u80fd\u7684 \\(\\text{Issue}\\) \uff0c\u8bf7\u5c06\u8981\u6c42\u63cf\u8ff0\u6e05\u695a\uff01 \u5982\u679c\u4f60\u60f3\u8ba9\u6211\u6dfb\u52a0\u4ec0\u4e48\u5947\u602a\u7684\u529f\u80fd\u7684\u8bdd\uff0c\u8bf7\u63d0\u4ea4 \\(\\text{Issue}\\) \u3002 \u5982\u679c\u4f60\u60f3\u62ff\u6211\u7684\u5e93\u8fdb\u884c\u5546\u7528\uff08\u4f1a\u6709\u8fd9\u6837\u7684\u4eba\u5417\uff1f\uff09\u2026\u2026\u8bf7\u9075\u5faa \\(\\text{MPLv2}\\) \u534f\u8bae\u3002","title":"\u4f60\u8fd9\u5e93\u8981\u662f\u4e0d\u4fdd\u719f\u548b\u529e\uff1f"},{"location":"NaDGenLib-docs/QuickStart/","text":"\u5feb\u901f\u4e0a\u624b \u00b6 \u672c\u8282\u5c06\u4f1a\u6559\u4f60\u5982\u4f55\u5bf9\u5feb\u901f\u4e0a\u624b NaDGenLib\u3002 PS\uff1a\u5efa\u8bae\u4f7f\u7528 Visual Studio Code \u6765\u7f16\u5199\u3002 \u57fa\u672c\u7ed3\u6784 \u00b6 \u5982\u540c C++ \u7684\u57fa\u672c\u6846\u67b6\u4e00\u822c\uff0cNaDGenLib \u4e5f\u662f\u62e5\u6709\u81ea\u5df1\u7684\u57fa\u672c\u6846\u67b6\u3002 \u5982\u679c\u4f60\u53ea\u60f3\u5bf9\u62cd\uff0c\u4e0d\u60f3\u505a\u6570\u636e\u751f\u6210\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528\u5982\u4e0b\u6846\u67b6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; void YourFunction (){ FlushIOStream (); //TODO } int main (){ RedirectToFile ( \"filename\" ); //TODO return 0 ; } \u5982\u679c\u4f60\u662f\u9898\u76ee\u6570\u636e\u6784\u5efa\u8005\uff0c\u5efa\u8bae\u60a8\u4f7f\u7528\u5982\u4e0b\u6846\u67b6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; void YourFunction ( int label ){ FlushIOStream (); //TODO } int main (){ RegisterStdProgram ( \"stdpath\" ); AutoGenerate ( \"filename%d.in\" , 1 , 4 , YourFunction , true ); return 0 ; } \u751f\u6210\u5668 \u00b6 NaDGenLib \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u6784\u9020\u65b9\u6848\u90fd\u53eb\u505a\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u4f8b\u5982\u65e0\u6839\u6811\u751f\u6210\u5668 NoRootTree \uff0c\u6709\u5411\u65e0\u73af\u56fe\u751f\u6210\u5668 DAG \u3002 \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u57fa\u672c\u4e0a\u90fd\u6709 Generate \u548c Output \u65b9\u6cd5\uff0c\u6709\u7684\u751f\u6210\u5668\u8fd8\u62e5\u6709 AutoMode \u65b9\u6cd5\u3002 Warning \u8b66\u544a\uff01Generate + Output \u5e76\u4e0d\u7b49\u4e8e AutoMode\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u751f\u6210\u5668 AntiSPFA \u8c03\u7528 Generate \u5b8c\u540e\u4f7f\u7528 Output \u53ea\u4f1a\u8f93\u51fa\u8fb9\u3002\u800c\u4f7f\u7528 AutoMode \u5219\u4f1a\u8f93\u51fa\u70b9\u6570\uff0c\u8fb9\u6570\uff0c\u8d77\u70b9\u548c\u5e26\u6743\u8fb9\u3002 \u4e0b\u9762\u662f\u6bcf\u4e2a\u751f\u6210\u5668\u652f\u6301\u7684\u65b9\u6cd5\u901f\u89c8\uff1a \u751f\u6210\u5668 \u652f\u6301 Generate \u652f\u6301 Output \u5907\u6ce8 Random \\(\\times\\) \\(\\times\\) \u751f\u6210\u968f\u673a\u6570\uff0c\u88ab\u62c6\u5206\u6210\u4e86\u4e09\u4e2a\u51fd\u6570\uff0c\u76f4\u63a5\u8fd4\u56de\u503c Sequence \\(\\checkmark\\) \\(\\times\\) \u751f\u6210\u5e8f\u5217\uff0cGenerate \u65f6\u5305\u542b Output \u4e86 Permutation \\(\\checkmark\\) \\(\\times\\) \u751f\u6210\u6392\u5217\uff0cGenerate \u65f6\u5305\u542b Output \u4e86 Graph \\(\\times\\) \\(\\checkmark\\) \u4f5c\u4e3a\u57fa\u7c7b\uff0c\u5c3d\u91cf\u5c11\u7528 NoRootTree \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u65e0\u6839\u6811 DaisyChain \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u83ca\u82b1\u94fe AntiSPFA \\(\\checkmark\\) \\(\\checkmark\\) \u652f\u6301 AutoMode RandomGraph \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u968f\u673a\u56fe DAG \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u6709\u5411\u65e0\u73af\u56fe Cactus \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u4ed9\u4eba\u638c \u5982\u679c\u8fd8\u4e0d\u5927\u660e\u767d\u600e\u4e48\u7528\uff0c\u8fd9\u91cc\u7ed9\u4f60\u4e00\u4e2a\u793a\u4f8b\uff1a 1 2 3 4 5 6 7 8 9 10 11 //\u751f\u6210\u4e00\u68f5\u65e0\u6839\u6811 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); NoRootTree nrt ( 30 ); nrt . Generate (); nrt . Output (); return 0 ; } \u5176\u4ed6\u7684\u751f\u6210\u5668\u4e5f\u50cf\u4e0a\u9762\u793a\u4f8b\u7684\u90a3\u6837\u5199\u5c31\u884c\uff0c\u53ea\u4e0d\u8fc7\u6bcf\u4e2a\u751f\u6210\u5668\u7684\u6784\u9020\u65b9\u6848\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u788d\u4e8e\u7bc7\u5e45\u9650\u5236\u540e\u9762\u5c06\u4f1a\u63d0\u5230\u6bcf\u4e2a\u751f\u6210\u5668\u5177\u4f53\u7684\u6784\u9020\u65b9\u6cd5\u548c\u652f\u6301\u7684\u65b9\u6cd5\u3002","title":"\u5feb\u901f\u4e0a\u624b"},{"location":"NaDGenLib-docs/QuickStart/#_1","text":"\u672c\u8282\u5c06\u4f1a\u6559\u4f60\u5982\u4f55\u5bf9\u5feb\u901f\u4e0a\u624b NaDGenLib\u3002 PS\uff1a\u5efa\u8bae\u4f7f\u7528 Visual Studio Code \u6765\u7f16\u5199\u3002","title":"\u5feb\u901f\u4e0a\u624b"},{"location":"NaDGenLib-docs/QuickStart/#_2","text":"\u5982\u540c C++ \u7684\u57fa\u672c\u6846\u67b6\u4e00\u822c\uff0cNaDGenLib \u4e5f\u662f\u62e5\u6709\u81ea\u5df1\u7684\u57fa\u672c\u6846\u67b6\u3002 \u5982\u679c\u4f60\u53ea\u60f3\u5bf9\u62cd\uff0c\u4e0d\u60f3\u505a\u6570\u636e\u751f\u6210\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528\u5982\u4e0b\u6846\u67b6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; void YourFunction (){ FlushIOStream (); //TODO } int main (){ RedirectToFile ( \"filename\" ); //TODO return 0 ; } \u5982\u679c\u4f60\u662f\u9898\u76ee\u6570\u636e\u6784\u5efa\u8005\uff0c\u5efa\u8bae\u60a8\u4f7f\u7528\u5982\u4e0b\u6846\u67b6\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; void YourFunction ( int label ){ FlushIOStream (); //TODO } int main (){ RegisterStdProgram ( \"stdpath\" ); AutoGenerate ( \"filename%d.in\" , 1 , 4 , YourFunction , true ); return 0 ; }","title":"\u57fa\u672c\u7ed3\u6784"},{"location":"NaDGenLib-docs/QuickStart/#_3","text":"NaDGenLib \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u6784\u9020\u65b9\u6848\u90fd\u53eb\u505a\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u4f8b\u5982\u65e0\u6839\u6811\u751f\u6210\u5668 NoRootTree \uff0c\u6709\u5411\u65e0\u73af\u56fe\u751f\u6210\u5668 DAG \u3002 \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u57fa\u672c\u4e0a\u90fd\u6709 Generate \u548c Output \u65b9\u6cd5\uff0c\u6709\u7684\u751f\u6210\u5668\u8fd8\u62e5\u6709 AutoMode \u65b9\u6cd5\u3002 Warning \u8b66\u544a\uff01Generate + Output \u5e76\u4e0d\u7b49\u4e8e AutoMode\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u751f\u6210\u5668 AntiSPFA \u8c03\u7528 Generate \u5b8c\u540e\u4f7f\u7528 Output \u53ea\u4f1a\u8f93\u51fa\u8fb9\u3002\u800c\u4f7f\u7528 AutoMode \u5219\u4f1a\u8f93\u51fa\u70b9\u6570\uff0c\u8fb9\u6570\uff0c\u8d77\u70b9\u548c\u5e26\u6743\u8fb9\u3002 \u4e0b\u9762\u662f\u6bcf\u4e2a\u751f\u6210\u5668\u652f\u6301\u7684\u65b9\u6cd5\u901f\u89c8\uff1a \u751f\u6210\u5668 \u652f\u6301 Generate \u652f\u6301 Output \u5907\u6ce8 Random \\(\\times\\) \\(\\times\\) \u751f\u6210\u968f\u673a\u6570\uff0c\u88ab\u62c6\u5206\u6210\u4e86\u4e09\u4e2a\u51fd\u6570\uff0c\u76f4\u63a5\u8fd4\u56de\u503c Sequence \\(\\checkmark\\) \\(\\times\\) \u751f\u6210\u5e8f\u5217\uff0cGenerate \u65f6\u5305\u542b Output \u4e86 Permutation \\(\\checkmark\\) \\(\\times\\) \u751f\u6210\u6392\u5217\uff0cGenerate \u65f6\u5305\u542b Output \u4e86 Graph \\(\\times\\) \\(\\checkmark\\) \u4f5c\u4e3a\u57fa\u7c7b\uff0c\u5c3d\u91cf\u5c11\u7528 NoRootTree \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u65e0\u6839\u6811 DaisyChain \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u83ca\u82b1\u94fe AntiSPFA \\(\\checkmark\\) \\(\\checkmark\\) \u652f\u6301 AutoMode RandomGraph \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u968f\u673a\u56fe DAG \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u6709\u5411\u65e0\u73af\u56fe Cactus \\(\\checkmark\\) \\(\\checkmark\\) \u751f\u6210\u4ed9\u4eba\u638c \u5982\u679c\u8fd8\u4e0d\u5927\u660e\u767d\u600e\u4e48\u7528\uff0c\u8fd9\u91cc\u7ed9\u4f60\u4e00\u4e2a\u793a\u4f8b\uff1a 1 2 3 4 5 6 7 8 9 10 11 //\u751f\u6210\u4e00\u68f5\u65e0\u6839\u6811 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); NoRootTree nrt ( 30 ); nrt . Generate (); nrt . Output (); return 0 ; } \u5176\u4ed6\u7684\u751f\u6210\u5668\u4e5f\u50cf\u4e0a\u9762\u793a\u4f8b\u7684\u90a3\u6837\u5199\u5c31\u884c\uff0c\u53ea\u4e0d\u8fc7\u6bcf\u4e2a\u751f\u6210\u5668\u7684\u6784\u9020\u65b9\u6848\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u788d\u4e8e\u7bc7\u5e45\u9650\u5236\u540e\u9762\u5c06\u4f1a\u63d0\u5230\u6bcf\u4e2a\u751f\u6210\u5668\u5177\u4f53\u7684\u6784\u9020\u65b9\u6cd5\u548c\u652f\u6301\u7684\u65b9\u6cd5\u3002","title":"\u751f\u6210\u5668"},{"location":"NaDGenLib-docs/startup/","text":"\u5f00\u59cb\u4f7f\u7528 NaDGenLib \u00b6 \u6b22\u8fce\u6765\u5230 NaDGenLib \u7684\u6559\u5b66\u5173\u5361\uff0c\u5e0c\u671b\u5728\u8fd9\u91cc\u80fd\u627e\u5230\u4f60\u80fd\u6709\u6240\u6536\u83b7\u3002 \u5982\u679c\u6587\u6863\u6709\u95ee\u9898\uff0c\u8bf7\u63d0\u4ea4\u5728\u9879\u76ee\u91cc Issue \u6765\u8fdb\u884c\u53cd\u9988\uff0c\u611f\u8c22\u5927\u5bb6\u5bf9 NaDGenLib \u7684\u652f\u6301\uff01\uff01 NaDGenLib \u662f\u4e00\u4e2a\u5e73\u51e1\u7684\u6570\u636e\u751f\u6210\u5668\uff0c\u76ee\u7684\u662f\u5b9e\u73b0\u77ed\u65f6\u7684\u4e2d\u7b49\u5f3a\u5ea6\u6570\u636e\u751f\u6210\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5bf9 NaDGenLib \u7684\u4f7f\u7528\u5427\u3002 \u4f7f\u7528 NaDGenLib \u00b6 NaDGenLib \u4f7f\u7528 C++ \u7f16\u5199\uff0c\u5728\u5b89\u88c5\u597d C++ \u672c\u5730\u5de5\u5177\u94fe\u7684\u7535\u8111\u4e0a\uff0c\u4e0b\u8f7d Release \u4e2d\u7684 genlib.h \u5e76\u653e\u5165\u4f60\u7f16\u8bd1\u5668\u7684 include \u6587\u4ef6\u5939\u4e2d\u6216\u5de5\u4f5c\u76ee\u5f55\uff08\u53ef\u4ee5\u53c2\u8003 testlib.h \u7684\u5b89\u88c5\uff09 NaDGenLib \u53ef\u4ee5\u5e2e\u52a9\u4f60\u4f7f\u7528 C++ \u8bed\u8a00\u6765\u5feb\u901f\u7f16\u5199\u4e00\u4e2a\u6570\u636e\u751f\u6210\u5668\uff0c\u4f60\u53ef\u4ee5\u63a7\u5236\u8f93\u5165\u8f93\u51fa\u6587\u4ef6\uff0c\u5e76\u5c06\u6807\u51c6\u7a0b\u5e8f\u7684\u7ed3\u679c\u5199\u5165\u5230\u8f93\u51fa\u6587\u4ef6\u4e2d\u3002 \u5982\u679c\u4f60\u60f3\u4e86\u89e3 NaDGenLib \u7684\u4f7f\u7528\uff0c\u6216\u8005\u60f3\u8981\u73b0\u6210\u7684\u6e90\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u53c2\u8003\u672c\u9879\u76ee\u7684 samples \u90e8\u5206\u3002","title":"\u5f00\u59cb"},{"location":"NaDGenLib-docs/startup/#nadgenlib","text":"\u6b22\u8fce\u6765\u5230 NaDGenLib \u7684\u6559\u5b66\u5173\u5361\uff0c\u5e0c\u671b\u5728\u8fd9\u91cc\u80fd\u627e\u5230\u4f60\u80fd\u6709\u6240\u6536\u83b7\u3002 \u5982\u679c\u6587\u6863\u6709\u95ee\u9898\uff0c\u8bf7\u63d0\u4ea4\u5728\u9879\u76ee\u91cc Issue \u6765\u8fdb\u884c\u53cd\u9988\uff0c\u611f\u8c22\u5927\u5bb6\u5bf9 NaDGenLib \u7684\u652f\u6301\uff01\uff01 NaDGenLib \u662f\u4e00\u4e2a\u5e73\u51e1\u7684\u6570\u636e\u751f\u6210\u5668\uff0c\u76ee\u7684\u662f\u5b9e\u73b0\u77ed\u65f6\u7684\u4e2d\u7b49\u5f3a\u5ea6\u6570\u636e\u751f\u6210\u3002 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u5f00\u59cb\u5bf9 NaDGenLib \u7684\u4f7f\u7528\u5427\u3002","title":"\u5f00\u59cb\u4f7f\u7528 NaDGenLib"},{"location":"NaDGenLib-docs/startup/#nadgenlib_1","text":"NaDGenLib \u4f7f\u7528 C++ \u7f16\u5199\uff0c\u5728\u5b89\u88c5\u597d C++ \u672c\u5730\u5de5\u5177\u94fe\u7684\u7535\u8111\u4e0a\uff0c\u4e0b\u8f7d Release \u4e2d\u7684 genlib.h \u5e76\u653e\u5165\u4f60\u7f16\u8bd1\u5668\u7684 include \u6587\u4ef6\u5939\u4e2d\u6216\u5de5\u4f5c\u76ee\u5f55\uff08\u53ef\u4ee5\u53c2\u8003 testlib.h \u7684\u5b89\u88c5\uff09 NaDGenLib \u53ef\u4ee5\u5e2e\u52a9\u4f60\u4f7f\u7528 C++ \u8bed\u8a00\u6765\u5feb\u901f\u7f16\u5199\u4e00\u4e2a\u6570\u636e\u751f\u6210\u5668\uff0c\u4f60\u53ef\u4ee5\u63a7\u5236\u8f93\u5165\u8f93\u51fa\u6587\u4ef6\uff0c\u5e76\u5c06\u6807\u51c6\u7a0b\u5e8f\u7684\u7ed3\u679c\u5199\u5165\u5230\u8f93\u51fa\u6587\u4ef6\u4e2d\u3002 \u5982\u679c\u4f60\u60f3\u4e86\u89e3 NaDGenLib \u7684\u4f7f\u7528\uff0c\u6216\u8005\u60f3\u8981\u73b0\u6210\u7684\u6e90\u7a0b\u5e8f\uff0c\u53ef\u4ee5\u53c2\u8003\u672c\u9879\u76ee\u7684 samples \u90e8\u5206\u3002","title":"\u4f7f\u7528 NaDGenLib"},{"location":"NaDGenLib-docs/graph/Graph/","text":"Graph \u7c7b \u00b6 \u7528\u4e8e\u63d0\u4f9b\u5b58\u653e\u56fe\u7684\u5bb9\u5668\uff0c\u5e76\u652f\u6301\u4e0e\u751f\u6210\u6570\u636e\u76f8\u5173\u7684\u51fd\u6570\u3002 Warning \u8be5\u7c7b\u591a\u7528\u4f5c\u57fa\u7c7b\uff0c\u4e0d\u5efa\u8bae\u5927\u5bb6\u76f4\u63a5\u4f7f\u7528 \u81ea\u5b9a\u4e49\u751f\u6210\u7684\u65f6\u5019\uff0c\u8bf7\u5c3d\u91cf\u4f7f\u7528\u7ee7\u627f\u7684\u65b9\u5f0f\u800c\u4e0d\u662f\u521b\u5efa\u5b9e\u4f8b\u3002 \u516c\u5f00\u7684\u65b9\u6cd5\uff1a \u00b6 \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Graph( int verCount, bool undirectedMap = false, bool weightedMap = false, bool muiltiedgeCheck = false, bool loopCheck = false ) bool add_edge(int from, int to) bool add_edge(int from, int to, int weight) void clear(void) int GetEdgeCount(void) void Output(bool shuffleOutput = true) ~Graph(void) \u8be6\u7ec6\u6ce8\u89e3\uff1a \u00b6 Graph \u6784\u9020 \u00b6 \u63cf\u8ff0\uff1a Graph \u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 5 6 7 Graph :: Graph ( [ in ] int verCount , [ in , optional ] bool undirectedMap , [ in , optional ] bool weightedMap , [ in , optional ] muiltiedgeCheck , [ in , optional ] loopCheck ); \u53c2\u6570\uff1a verCount \uff1a\u56fe\u7684\u70b9\u6570 undirectedMap \uff1a\u65e0\u5411\u56fe\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u6709\u5411\u56fe\uff08false\uff09 weightedMap \uff1a\u5e26\u6743\u56fe\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u4e0d\u5e26\u6743\uff08false\uff09 muiltiedgeCheck \uff1a\u91cd\u8fb9\u68c0\u67e5\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u5173\u95ed\uff08false\uff09 loopCheck \uff1a\u81ea\u73af\u68c0\u67e5\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u5173\u95ed\uff08false\uff09 add_edge \u65b9\u6cd5 \u00b6 \u63cf\u8ff0\uff1a \u7528\u4e8e\u6dfb\u52a0\u4e00\u6761\u8fb9\uff0c\u8fb9\u7684\u7c7b\u578b\u8bf7\u53c2\u7167\u6784\u9020\u51fd\u6570\u4e2d weightedMap \u90e8\u5206\u3002 \u8bed\u6cd5\uff1a \u4e0d\u5e26\u6743\u8fb9\u91cd\u8f7d\uff1a 1 2 3 4 bool Graph::add_edge ( [ in ] int from , [ in ] int to ); \u5e26\u8fb9\u6743\u91cd\u8f7d\uff1a 1 2 3 4 5 bool Graph::add_edge ( [ in ] int from , [ in ] int to , [ in ] int weight ); \u53c2\u6570\uff1a from \uff1a\u8fb9\u7684\u8d77\u70b9 to \uff1a\u8fb9\u7684\u7ec8\u70b9 weight \uff1a\u8fb9\u7684\u8fb9\u6743\uff08 Override!! \uff09 \u8fd4\u56de\uff1a \u82e5\u8fb9\u6210\u529f\u6dfb\u52a0\uff0c\u5219\u8fd4\u56de true \u5426\u5219\u8fd4\u56de false \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u7684\u4e24\u4e2a\u91cd\u8f7d\u5b8c\u5168\u4e0d\u540c\uff0c\u8bf7\u6ce8\u610f\u4e0d\u8981\u6df7\u6dc6\uff0c \u82e5\u4e0d\u5e26\u6743\u56fe\u4f7f\u7528\u4e86\u5e26\u6743\u56fe\u7684 add_edge \uff0c\u5219\u4f1a\u89e6\u53d1\u65ad\u8a00\u5931\u8d25\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002","title":"Graph \u7c7b"},{"location":"NaDGenLib-docs/graph/Graph/#graph","text":"\u7528\u4e8e\u63d0\u4f9b\u5b58\u653e\u56fe\u7684\u5bb9\u5668\uff0c\u5e76\u652f\u6301\u4e0e\u751f\u6210\u6570\u636e\u76f8\u5173\u7684\u51fd\u6570\u3002 Warning \u8be5\u7c7b\u591a\u7528\u4f5c\u57fa\u7c7b\uff0c\u4e0d\u5efa\u8bae\u5927\u5bb6\u76f4\u63a5\u4f7f\u7528 \u81ea\u5b9a\u4e49\u751f\u6210\u7684\u65f6\u5019\uff0c\u8bf7\u5c3d\u91cf\u4f7f\u7528\u7ee7\u627f\u7684\u65b9\u5f0f\u800c\u4e0d\u662f\u521b\u5efa\u5b9e\u4f8b\u3002","title":"Graph \u7c7b"},{"location":"NaDGenLib-docs/graph/Graph/#_1","text":"\u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Graph( int verCount, bool undirectedMap = false, bool weightedMap = false, bool muiltiedgeCheck = false, bool loopCheck = false ) bool add_edge(int from, int to) bool add_edge(int from, int to, int weight) void clear(void) int GetEdgeCount(void) void Output(bool shuffleOutput = true) ~Graph(void)","title":"\u516c\u5f00\u7684\u65b9\u6cd5\uff1a"},{"location":"NaDGenLib-docs/graph/Graph/#_2","text":"","title":"\u8be6\u7ec6\u6ce8\u89e3\uff1a"},{"location":"NaDGenLib-docs/graph/Graph/#graph_1","text":"\u63cf\u8ff0\uff1a Graph \u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 5 6 7 Graph :: Graph ( [ in ] int verCount , [ in , optional ] bool undirectedMap , [ in , optional ] bool weightedMap , [ in , optional ] muiltiedgeCheck , [ in , optional ] loopCheck ); \u53c2\u6570\uff1a verCount \uff1a\u56fe\u7684\u70b9\u6570 undirectedMap \uff1a\u65e0\u5411\u56fe\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u6709\u5411\u56fe\uff08false\uff09 weightedMap \uff1a\u5e26\u6743\u56fe\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u4e0d\u5e26\u6743\uff08false\uff09 muiltiedgeCheck \uff1a\u91cd\u8fb9\u68c0\u67e5\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u5173\u95ed\uff08false\uff09 loopCheck \uff1a\u81ea\u73af\u68c0\u67e5\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e3a\u5173\u95ed\uff08false\uff09","title":"Graph \u6784\u9020"},{"location":"NaDGenLib-docs/graph/Graph/#add_edge","text":"\u63cf\u8ff0\uff1a \u7528\u4e8e\u6dfb\u52a0\u4e00\u6761\u8fb9\uff0c\u8fb9\u7684\u7c7b\u578b\u8bf7\u53c2\u7167\u6784\u9020\u51fd\u6570\u4e2d weightedMap \u90e8\u5206\u3002 \u8bed\u6cd5\uff1a \u4e0d\u5e26\u6743\u8fb9\u91cd\u8f7d\uff1a 1 2 3 4 bool Graph::add_edge ( [ in ] int from , [ in ] int to ); \u5e26\u8fb9\u6743\u91cd\u8f7d\uff1a 1 2 3 4 5 bool Graph::add_edge ( [ in ] int from , [ in ] int to , [ in ] int weight ); \u53c2\u6570\uff1a from \uff1a\u8fb9\u7684\u8d77\u70b9 to \uff1a\u8fb9\u7684\u7ec8\u70b9 weight \uff1a\u8fb9\u7684\u8fb9\u6743\uff08 Override!! \uff09 \u8fd4\u56de\uff1a \u82e5\u8fb9\u6210\u529f\u6dfb\u52a0\uff0c\u5219\u8fd4\u56de true \u5426\u5219\u8fd4\u56de false \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u7684\u4e24\u4e2a\u91cd\u8f7d\u5b8c\u5168\u4e0d\u540c\uff0c\u8bf7\u6ce8\u610f\u4e0d\u8981\u6df7\u6dc6\uff0c \u82e5\u4e0d\u5e26\u6743\u56fe\u4f7f\u7528\u4e86\u5e26\u6743\u56fe\u7684 add_edge \uff0c\u5219\u4f1a\u89e6\u53d1\u65ad\u8a00\u5931\u8d25\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002","title":"add_edge \u65b9\u6cd5"},{"location":"NaDGenLib-docs/random/Random/","text":"Random \u7c7b \u00b6 \u968f\u673a\u6570\u751f\u6210\u5668\uff0c\u80fd\u751f\u6210\u72ec\u7acb\u7684\u968f\u673a\u6570 \u516c\u5f00\u7684\u65b9\u6cd5 \u00b6 \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Random(void) long long irand(long long l, long long r) long double frand(long double l, long double r) string srand(unsigned long long length, string charset = default_charset) \u8be6\u7ec6\u6ce8\u89e3 \u00b6 irand \u65b9\u6cd5 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6574\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long long Random::irand ( [ in ] long long l , [ in ] long long r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6574\u6570\u3002 frand \u65b9\u6cd5 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long double Random::frand ( [ in ] long double l , [ in ] long double r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 srand \u65b9\u6cd5 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u6307\u5b9a\u957f\u5ea6\u548c\u5b57\u7b26\u96c6\u7684\u5b57\u7b26\u4e32\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 string Random::srand ( [ in ] unsigned long long length , [ in , optional ] string charset ); \u53c2\u6570\uff1a length \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002 charset \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u96c6\uff0c\u9ed8\u8ba4\u4e3a 0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZMXNCBV \u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u5b57\u7b26\u4e32\u3002 \u4f7f\u7528\u793a\u4f8b \u00b6 \u751f\u6210 \\(20\\) \u4e2a\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u968f\u673a\u6574\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; for ( int i = 1 ; i <= 20 ; i ++ ) { cout << rnd . irand ( 1 , 15 ) << endl ; } return 0 ; } \u751f\u6210 \\(10\\) \u4e2a\u8303\u56f4\u5728 \\([5,10]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; for ( int i = 1 ; i <= 20 ; i ++ ) { cout << rnd . frand ( 5 , 10 ) << endl ; } return 0 ; } \u751f\u6210\u957f\u5ea6\u4e3a \\(30\\) \u7684\u5b57\u7b26\u4e32\uff1a 1 2 3 4 5 6 7 8 9 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; cout << rnd . srand ( 30 ) << endl ; return 0 ; }","title":"Random \u7c7b"},{"location":"NaDGenLib-docs/random/Random/#random","text":"\u968f\u673a\u6570\u751f\u6210\u5668\uff0c\u80fd\u751f\u6210\u72ec\u7acb\u7684\u968f\u673a\u6570","title":"Random \u7c7b"},{"location":"NaDGenLib-docs/random/Random/#_1","text":"\u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Random(void) long long irand(long long l, long long r) long double frand(long double l, long double r) string srand(unsigned long long length, string charset = default_charset)","title":"\u516c\u5f00\u7684\u65b9\u6cd5"},{"location":"NaDGenLib-docs/random/Random/#_2","text":"","title":"\u8be6\u7ec6\u6ce8\u89e3"},{"location":"NaDGenLib-docs/random/Random/#irand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6574\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long long Random::irand ( [ in ] long long l , [ in ] long long r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6574\u6570\u3002","title":"irand \u65b9\u6cd5"},{"location":"NaDGenLib-docs/random/Random/#frand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long double Random::frand ( [ in ] long double l , [ in ] long double r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002","title":"frand \u65b9\u6cd5"},{"location":"NaDGenLib-docs/random/Random/#srand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u6307\u5b9a\u957f\u5ea6\u548c\u5b57\u7b26\u96c6\u7684\u5b57\u7b26\u4e32\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 string Random::srand ( [ in ] unsigned long long length , [ in , optional ] string charset ); \u53c2\u6570\uff1a length \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002 charset \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u96c6\uff0c\u9ed8\u8ba4\u4e3a 0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZMXNCBV \u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u5b57\u7b26\u4e32\u3002","title":"srand \u65b9\u6cd5"},{"location":"NaDGenLib-docs/random/Random/#_3","text":"\u751f\u6210 \\(20\\) \u4e2a\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u968f\u673a\u6574\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; for ( int i = 1 ; i <= 20 ; i ++ ) { cout << rnd . irand ( 1 , 15 ) << endl ; } return 0 ; } \u751f\u6210 \\(10\\) \u4e2a\u8303\u56f4\u5728 \\([5,10]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; for ( int i = 1 ; i <= 20 ; i ++ ) { cout << rnd . frand ( 5 , 10 ) << endl ; } return 0 ; } \u751f\u6210\u957f\u5ea6\u4e3a \\(30\\) \u7684\u5b57\u7b26\u4e32\uff1a 1 2 3 4 5 6 7 8 9 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); Random rnd ; cout << rnd . srand ( 30 ) << endl ; return 0 ; }","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"NaDGenLib-docs/random/frand/","text":"frand \u51fd\u6570 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long double frand ( [ in ] long double l , [ in ] long double r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002 \u4f7f\u7528\u793a\u4f8b \u00b6 \u751f\u6210 \\(10\\) \u4e2a\u8303\u56f4\u5728 \\([5,10]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); for ( int i = 1 ; i <= 20 ; i ++ ) { cout << frand ( 5 , 10 ) << endl ; } return 0 ; }","title":"frand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/frand/#frand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long double frand ( [ in ] long double l , [ in ] long double r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6d6e\u70b9\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6d6e\u70b9\u6570\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002","title":"frand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/frand/#_1","text":"\u751f\u6210 \\(10\\) \u4e2a\u8303\u56f4\u5728 \\([5,10]\\) \u7684\u968f\u673a\u6d6e\u70b9\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); for ( int i = 1 ; i <= 20 ; i ++ ) { cout << frand ( 5 , 10 ) << endl ; } return 0 ; }","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"NaDGenLib-docs/random/irand/","text":"irand \u51fd\u6570 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6574\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long long irand ( [ in ] long long l , [ in ] long long r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6574\u6570\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002 \u4f7f\u7528\u793a\u4f8b \u00b6 \u751f\u6210 \\(20\\) \u4e2a\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u968f\u673a\u6574\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); for ( int i = 1 ; i <= 20 ; i ++ ) { cout << irand ( 1 , 15 ) << endl ; } return 0 ; }","title":"irand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/irand/#irand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u8303\u56f4\u5728 \\([l,r]\\) \u7684\u968f\u673a\u6574\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 long long irand ( [ in ] long long l , [ in ] long long r ); \u53c2\u6570\uff1a l \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5c0f\u503c\u3002 r \uff1a\u8868\u793a\u751f\u6210\u968f\u673a\u6574\u6570\u7684\u6700\u5927\u503c\u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u6574\u6570\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u6574\u6570\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002","title":"irand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/irand/#_1","text":"\u751f\u6210 \\(20\\) \u4e2a\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u968f\u673a\u6574\u6570\uff1a 1 2 3 4 5 6 7 8 9 10 11 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); for ( int i = 1 ; i <= 20 ; i ++ ) { cout << irand ( 1 , 15 ) << endl ; } return 0 ; }","title":"\u4f7f\u7528\u793a\u4f8b"},{"location":"NaDGenLib-docs/random/srand/","text":"srand \u51fd\u6570 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u6307\u5b9a\u957f\u5ea6\u548c\u5b57\u7b26\u96c6\u7684\u5b57\u7b26\u4e32\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 string Random::srand ( [ in ] unsigned long long length , [ in , optional ] string charset ); \u53c2\u6570\uff1a length \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002 charset \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u96c6\uff0c\u9ed8\u8ba4\u4e3a 0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZMXNCBV \u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u5b57\u7b26\u4e32\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002 \u8bf7\u6ce8\u610f\uff0c\u53ef\u80fd\u4f1a\u4e0e C \u6807\u51c6\u7684 srand(unsigned seed) \u51fd\u6570\u76f8\u6df7\u6dc6\u4ece\u800c\u5f15\u53d1\u7f16\u8bd1\u9519\u8bef\u3002 \u4f7f\u7528\u793a\u4f8b\uff1a \u00b6 \u751f\u6210\u957f\u5ea6\u4e3a \\(30\\) \u7684\u5b57\u7b26\u4e32\uff1a 1 2 3 4 5 6 7 8 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); cout << srand ( 30 ) << endl ; return 0 ; }","title":"srand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/srand/#srand","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u6307\u5b9a\u957f\u5ea6\u548c\u5b57\u7b26\u96c6\u7684\u5b57\u7b26\u4e32\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 string Random::srand ( [ in ] unsigned long long length , [ in , optional ] string charset ); \u53c2\u6570\uff1a length \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u3002 charset \uff1a\u8868\u793a\u751f\u6210\u5b57\u7b26\u4e32\u7684\u5b57\u7b26\u96c6\uff0c\u9ed8\u8ba4\u4e3a 0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZMXNCBV \u3002 \u8fd4\u56de\uff1a \u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8868\u793a\u751f\u6210\u7684\u968f\u673a\u5b57\u7b26\u4e32\u3002 \u8b66\u544a\uff1a \u8be5\u51fd\u6570\u8fd4\u56de\u7684\u7ed3\u679c\u5728\u5168\u5c40\u4e0a\u5e76\u4e0d\u72ec\u7acb\u3002 \u8bf7\u6ce8\u610f\uff0c\u53ef\u80fd\u4f1a\u4e0e C \u6807\u51c6\u7684 srand(unsigned seed) \u51fd\u6570\u76f8\u6df7\u6dc6\u4ece\u800c\u5f15\u53d1\u7f16\u8bd1\u9519\u8bef\u3002","title":"srand \u51fd\u6570"},{"location":"NaDGenLib-docs/random/srand/#_1","text":"\u751f\u6210\u957f\u5ea6\u4e3a \\(30\\) \u7684\u5b57\u7b26\u4e32\uff1a 1 2 3 4 5 6 7 8 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main (){ RedirectToFile ( \"in.in\" ); cout << srand ( 30 ) << endl ; return 0 ; }","title":"\u4f7f\u7528\u793a\u4f8b\uff1a"},{"location":"NaDGenLib-docs/seq_per/Permutation/","text":"Permutation \u7c7b \u00b6 \u6392\u5217\u751f\u6210\u5668\uff0c\u7528\u4e8e\u751f\u6210 \\([1,n]\\) \u7684\u6392\u5217\u3002 \u516c\u5f00\u7684\u65b9\u6cd5 \u00b6 \u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Permutation(unsigned length) void Generate(string split = \" \", string ends = \"\\n\") ~Permutation(void) \u8be6\u7ec6\u6ce8\u89e3 \u00b6 Permutation \u6784\u9020 \u00b6 \u63cf\u8ff0\uff1a \u6392\u5217\u7684\u6784\u9020\u51fd\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 Permutation :: Permutation ( [ in ] unsigned length ); \u53c2\u6570\uff1a length \uff1a\u6392\u5217\u957f\u5ea6\u3002 Generate \u65b9\u6cd5 \u00b6 \u63cf\u8ff0\uff1a \u751f\u6210\u5e76\u4f9d\u7167\u56fa\u5b9a\u683c\u5f0f\u8f93\u51fa\u6392\u5217\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 void Permutation::Generate ( [ in , optional ] string split , [ in , optional ] string ends ); \u53c2\u6570\uff1a split \uff1a\u5143\u7d20\u5206\u5272\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u7a7a\u683c\u3002 ends \uff1a\u6392\u5217\u8f93\u51fa\u7ed3\u675f\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u56de\u8f66\u3002 \u8b66\u544a\uff1a \u6ce8\u610f\uff0c split \u548c ends \u90fd\u5e94\u5f53\u4e3a\u5b57\u7b26\u4e32\u3002 \u4f7f\u7528\u793a\u4f8b \u00b6 \u751f\u6210\u957f\u5ea6\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u6392\u5217\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); int n = irand ( 1 , 15 ); cout << n << endl ; Permutation p ( n ); p . Generate (); return 0 ; }","title":"Permutation \u7c7b"},{"location":"NaDGenLib-docs/seq_per/Permutation/#permutation","text":"\u6392\u5217\u751f\u6210\u5668\uff0c\u7528\u4e8e\u751f\u6210 \\([1,n]\\) \u7684\u6392\u5217\u3002","title":"Permutation \u7c7b"},{"location":"NaDGenLib-docs/seq_per/Permutation/#_1","text":"\u8fd4\u56de\u7c7b\u578b \u51fd\u6570\u5b9a\u4e49 Permutation(unsigned length) void Generate(string split = \" \", string ends = \"\\n\") ~Permutation(void)","title":"\u516c\u5f00\u7684\u65b9\u6cd5"},{"location":"NaDGenLib-docs/seq_per/Permutation/#_2","text":"","title":"\u8be6\u7ec6\u6ce8\u89e3"},{"location":"NaDGenLib-docs/seq_per/Permutation/#permutation_1","text":"\u63cf\u8ff0\uff1a \u6392\u5217\u7684\u6784\u9020\u51fd\u6570\u3002 \u8bed\u6cd5\uff1a 1 2 3 Permutation :: Permutation ( [ in ] unsigned length ); \u53c2\u6570\uff1a length \uff1a\u6392\u5217\u957f\u5ea6\u3002","title":"Permutation \u6784\u9020"},{"location":"NaDGenLib-docs/seq_per/Permutation/#generate","text":"\u63cf\u8ff0\uff1a \u751f\u6210\u5e76\u4f9d\u7167\u56fa\u5b9a\u683c\u5f0f\u8f93\u51fa\u6392\u5217\u3002 \u8bed\u6cd5\uff1a 1 2 3 4 void Permutation::Generate ( [ in , optional ] string split , [ in , optional ] string ends ); \u53c2\u6570\uff1a split \uff1a\u5143\u7d20\u5206\u5272\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u7a7a\u683c\u3002 ends \uff1a\u6392\u5217\u8f93\u51fa\u7ed3\u675f\u65b9\u5f0f\uff0c\u9ed8\u8ba4\u4e3a\u56de\u8f66\u3002 \u8b66\u544a\uff1a \u6ce8\u610f\uff0c split \u548c ends \u90fd\u5e94\u5f53\u4e3a\u5b57\u7b26\u4e32\u3002","title":"Generate \u65b9\u6cd5"},{"location":"NaDGenLib-docs/seq_per/Permutation/#_3","text":"\u751f\u6210\u957f\u5ea6\u8303\u56f4\u5728 \\([1,15]\\) \u7684\u6392\u5217\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 #include \"genlib.h\" using namespace Generator ; using namespace std ; int main () { RedirectToFile ( \"in.in\" ); int n = irand ( 1 , 15 ); cout << n << endl ; Permutation p ( n ); p . Generate (); return 0 ; }","title":"\u4f7f\u7528\u793a\u4f8b"}]}